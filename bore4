#!/usr/bin/env bash
# ========================================================
# bore4 - Wrapper intelligent pour bore avec fallback IPv4
# ========================================================
# Ce script cr√©e des tunnels TCP vers bore.pub avec support
# automatique du fallback IPv4 quand IPv6 est indisponible
# ========================================================

set -euo pipefail

#!/usr/bin/env bash
# ========================================================
# bore4 - Wrapper intelligent pour bore avec fallback IPv4
# ========================================================
# Ce script cr√©e des tunnels TCP vers bore.pub avec support
# automatique du fallback IPv4 quand IPv6 est indisponible
# ========================================================

set -euo pipefail

# ========================================================
# CONFIGURATION ET VARIABLES
# ========================================================
HOST="bore.pub"          # Serveur bore par defaut
CACHE_FILE="$HOME/.bore4_cache"  # Cache local pour les IPs resolues
TIMEOUT=2                # Timeout pour les tests de connectivite
RETRIES=2                # Nombre de tentatives pour lancer bore
CONFIG_FILE="$HOME/.bore4rc"  # Fichier de config facultatif

# Charge le fichier de config s'il existe
[[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"

# ========================================================
# COULEURS POUR L'AFFICHAGE
# ========================================================
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
BLUE="\033[0;34m"
RESET="\033[0m"

# Affiche une animation de chargement pendant l'execution d'un processus
spinner() {
  local pid=$1
  local delay=0.1
  local spinstr='|/-\'
  while kill -0 "$pid" 2>/dev/null; do
    local temp=${spinstr#?}
    printf " [%c]  " "$spinstr"
    spinstr=$temp${spinstr%"$temp"}
    sleep $delay
    printf "\b\b\b\b\b\b"
  done
}

# Fonctions d'affichage avec couleurs pour les messages
log() { echo -e "${BLUE}üîπ $1${RESET}"; }      # Message info en bleu
warn() { echo -e "${YELLOW}‚ö†Ô∏è  $1${RESET}"; }      # Message avertissement en jaune
error() { echo -e "${RED}‚ùå $1${RESET}"; }     # Message erreur en rouge

print_help() {
cat <<EOF
bore4 v1.0 ‚Äî smart wrapper for bore with IPv4 fallback

Usage:
  bore4 <local_port> [bore options...]

Examples:
  bore4 59012
  bore4 3000 --secret mypass

Options:
  -h, --help    Show this help
EOF
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  print_help
  exit 0
fi

# R√©cup√®re le port local depuis les param√®tres
PORT="${1:-}"
if [[ -z "$PORT" ]]; then
  print_help
  exit 1
fi

shift || true
EXTRA_ARGS="$@"  # Arguments additionnels pour bore


# ============================================
# VALIDATION DU PORT
# ============================================
# V√©rifie que le port est un nombre valide
if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
  error "Invalid port: '$PORT'"
  echo
  echo "üí° Port must be a number between 1 and 65535"
  exit 1
fi

# V√©rifie que le port est dans la plage valide (1-65535)
if (( PORT < 1 || PORT > 65535 )); then
  error "Port out of range: $PORT"
  exit 1
fi

# ============================================
# V√âRIFICATION DU SERVICE LOCAL
# ============================================
# V√©rifie qu'un service √©coute bien sur le port
log "Checking local service on port $PORT..."

# D√©sactive temporairement l'exit sur erreur pour lsof
set +e
PROCESS_INFO=$(lsof -nP -iTCP:"$PORT" -sTCP:LISTEN 2>/dev/null | awk 'NR==2')
set -e

if [[ -z "$PROCESS_INFO" ]]; then
  error "No service is listening on localhost:$PORT"
  echo

  echo "üîé Diagnostics:"
  echo "   ‚Ä¢ Port $PORT is CLOSED"
  echo "   ‚Ä¢ Bore would create a tunnel to nowhere"
  echo

  echo "üí° Possible fixes:"
  echo "   ‚Ä¢ Start your service"
  echo "   ‚Ä¢ Check the port number"
  echo

  echo "üìä Active listening ports:"
  lsof -nP -iTCP -sTCP:LISTEN 2>/dev/null | head -n 10

  echo
  exit 1
fi

PROCESS_NAME=$(echo "$PROCESS_INFO" | awk '{print $1}')
PROCESS_PID=$(echo "$PROCESS_INFO" | awk '{print $2}')
PROCESS_ADDR=$(echo "$PROCESS_INFO" | awk '{print $9}')

log "Detected process: $PROCESS_NAME (PID $PROCESS_PID) on $PROCESS_ADDR ‚úî"






log "Checking IPv6 connectivity..."
# Test la connectivit√© IPv6 vers le serveur bore
if nc -6 -z -G "$TIMEOUT" "$HOST" 7835 >/dev/null 2>&1; then
  log "IPv6 OK ‚Üí using hostname"  # IPv6 disponible, utilise le hostname
  exec bore local "$PORT" --to "$HOST" $EXTRA_ARGS
fi

# ============================================
# FALLBACK IPV4 AVEC CACHE
# ============================================
# IPv6 indisponible, bascule sur IPv4
warn "IPv6 unavailable ‚Üí fallback IPv4"

# Essaie de r√©cup√©rer l'IP depuis le cache
IP=""
[[ -f "$CACHE_FILE" ]] && IP=$(cat "$CACHE_FILE")

# Si pas en cache, r√©sout l'IP via DNS (dig)
if [[ -z "$IP" ]]; then
  log "Resolving IPv4..."
  IP=$(dig +short "$HOST" | grep -E '^[0-9.]+' | head -n1)
  if [[ -z "$IP" ]]; then
    error "Failed to resolve IPv4"
    exit 1
  fi
  # Sauvegarde l'IP dans le cache pour les appels futurs
  echo "$IP" > "$CACHE_FILE"
fi

log "Using IPv4 $IP"

# ============================================
# D√âMARRAGE DE BORE AVEC RETRIES
# ============================================
# Lance bore avec retry automatique en cas d'√©chec
for ((i=1;i<=RETRIES;i++)); do
  log "Starting bore (attempt $i)..."
  bore local "$PORT" --to "$IP" $EXTRA_ARGS &
  pid=$!
  spinner $pid          # Affiche l'animation pendant l'ex√©cution
  wait $pid && break    # Attend la fin et sort si succ√®s
  warn "Attempt $i failed"  # Retry si √©chec
done
